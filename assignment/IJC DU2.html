<!DOCTYPE html PUBLIC "-//IETF//DTD HTML 3.0//EN//">
<html version="3"><head><style class="darkreader darkreader--fallback" media="screen"></style><style class="darkreader darkreader--text" media="screen"></style><style class="darkreader darkreader--invert" media="screen">.jfk-bubble.gtx-bubble, .captcheck_answer_label > input + img, span#closed_text > img[src^="https://www.gstatic.com/images/branding/googlelogo"], span[data-href^="https://www.hcaptcha.com/"] > #icon, embed[type="application/pdf"] {
    filter: invert(100%) hue-rotate(180deg) contrast(90%) !important;
}</style><style class="darkreader darkreader--inline" media="screen">[data-darkreader-inline-bgcolor] {
  background-color: var(--darkreader-inline-bgcolor) !important;
}
[data-darkreader-inline-bgimage] {
  background-image: var(--darkreader-inline-bgimage) !important;
}
[data-darkreader-inline-border] {
  border-color: var(--darkreader-inline-border) !important;
}
[data-darkreader-inline-border-bottom] {
  border-bottom-color: var(--darkreader-inline-border-bottom) !important;
}
[data-darkreader-inline-border-left] {
  border-left-color: var(--darkreader-inline-border-left) !important;
}
[data-darkreader-inline-border-right] {
  border-right-color: var(--darkreader-inline-border-right) !important;
}
[data-darkreader-inline-border-top] {
  border-top-color: var(--darkreader-inline-border-top) !important;
}
[data-darkreader-inline-boxshadow] {
  box-shadow: var(--darkreader-inline-boxshadow) !important;
}
[data-darkreader-inline-color] {
  color: var(--darkreader-inline-color) !important;
}
[data-darkreader-inline-fill] {
  fill: var(--darkreader-inline-fill) !important;
}
[data-darkreader-inline-stroke] {
  stroke: var(--darkreader-inline-stroke) !important;
}
[data-darkreader-inline-outline] {
  outline-color: var(--darkreader-inline-outline) !important;
}
[data-darkreader-inline-stopcolor] {
  stop-color: var(--darkreader-inline-stopcolor) !important;
}</style><style class="darkreader darkreader--variables" media="screen">:root {
   --darkreader-neutral-background: #131516;
   --darkreader-neutral-text: #d8d4cf;
   --darkreader-selection-background: #004daa;
   --darkreader-selection-text: #e8e6e3;
}</style><script class="darkreader darkreader--proxy">(function injectProxy() {
        document.dispatchEvent(new CustomEvent('__darkreader__inlineScriptsAllowed'));
        const addRuleDescriptor = Object.getOwnPropertyDescriptor(CSSStyleSheet.prototype, 'addRule');
        const insertRuleDescriptor = Object.getOwnPropertyDescriptor(CSSStyleSheet.prototype, 'insertRule');
        const deleteRuleDescriptor = Object.getOwnPropertyDescriptor(CSSStyleSheet.prototype, 'deleteRule');
        const removeRuleDescriptor = Object.getOwnPropertyDescriptor(CSSStyleSheet.prototype, 'removeRule');
        const cleanUp = () => {
            Object.defineProperty(CSSStyleSheet.prototype, 'addRule', addRuleDescriptor);
            Object.defineProperty(CSSStyleSheet.prototype, 'insertRule', insertRuleDescriptor);
            Object.defineProperty(CSSStyleSheet.prototype, 'deleteRule', deleteRuleDescriptor);
            Object.defineProperty(CSSStyleSheet.prototype, 'removeRule', removeRuleDescriptor);
            document.removeEventListener('__darkreader__cleanUp', cleanUp);
            document.removeEventListener('__darkreader__addUndefinedResolver', addUndefinedResolver);
        };
        const addUndefinedResolver = (e) => {
            customElements.whenDefined(e.detail.tag).then(() => {
                document.dispatchEvent(new CustomEvent('__darkreader__isDefined', { detail: { tag: e.detail.tag } }));
            });
        };
        document.addEventListener('__darkreader__cleanUp', cleanUp);
        document.addEventListener('__darkreader__addUndefinedResolver', addUndefinedResolver);
        const updateSheetEvent = new Event('__darkreader__updateSheet');
        function proxyAddRule(selector, style, index) {
            addRuleDescriptor.value.call(this, selector, style, index);
            if (this.ownerNode && !this.ownerNode.classList.contains('darkreader')) {
                this.ownerNode.dispatchEvent(updateSheetEvent);
            }
            return -1;
        }
        function proxyInsertRule(rule, index) {
            const returnValue = insertRuleDescriptor.value.call(this, rule, index);
            if (this.ownerNode && !this.ownerNode.classList.contains('darkreader')) {
                this.ownerNode.dispatchEvent(updateSheetEvent);
            }
            return returnValue;
        }
        function proxyDeleteRule(index) {
            deleteRuleDescriptor.value.call(this, index);
            if (this.ownerNode && !this.ownerNode.classList.contains('darkreader')) {
                this.ownerNode.dispatchEvent(updateSheetEvent);
            }
        }
        function proxyRemoveRule(index) {
            removeRuleDescriptor.value.call(this, index);
            if (this.ownerNode && !this.ownerNode.classList.contains('darkreader')) {
                this.ownerNode.dispatchEvent(updateSheetEvent);
            }
        }
        Object.defineProperty(CSSStyleSheet.prototype, 'addRule', Object.assign({}, addRuleDescriptor, { value: proxyAddRule }));
        Object.defineProperty(CSSStyleSheet.prototype, 'insertRule', Object.assign({}, insertRuleDescriptor, { value: proxyInsertRule }));
        Object.defineProperty(CSSStyleSheet.prototype, 'deleteRule', Object.assign({}, deleteRuleDescriptor, { value: proxyDeleteRule }));
        Object.defineProperty(CSSStyleSheet.prototype, 'removeRule', Object.assign({}, removeRuleDescriptor, { value: proxyRemoveRule }));
    })()</script><style class="darkreader darkreader--user-agent" media="screen">html {
    background-color: #181a1b !important;
}
html, body, input, textarea, select, button {
    background-color: #181a1b;
}
html, body, input, textarea, select, button {
    border-color: #736b5e;
    color: #e8e6e3;
}
a {
    color: #3391ff;
}
table {
    border-color: #545b5e;
}
::placeholder {
    color: #b2aba1;
}
input:-webkit-autofill,
textarea:-webkit-autofill,
select:-webkit-autofill {
    background-color: #555b00 !important;
    color: #e8e6e3 !important;
}
::-webkit-scrollbar {
    background-color: #202324;
    color: #aba499;
}
::-webkit-scrollbar-thumb {
    background-color: #454a4d;
}
::-webkit-scrollbar-thumb:hover {
    background-color: #575e62;
}
::-webkit-scrollbar-thumb:active {
    background-color: #484e51;
}
::-webkit-scrollbar-corner {
    background-color: #181a1b;
}
* {
    scrollbar-color: #454a4d #202324;
}
::selection {
    background-color: #004daa !important;
    color: #e8e6e3 !important;
}
::-moz-selection {
    background-color: #004daa !important;
    color: #e8e6e3 !important;
}</style>
    <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-2">
    <meta http-equiv="Content-language" content="cs">
    <title>IJC: DU2 </title>
<meta name="darkreader" content="564d06bbba2d20c2abd39ce4e701c1da"><style class="darkreader darkreader--override" media="screen">.vimvixen-hint {
    background-color: #7b5300 !important;
    border-color: #d8b013 !important;
    color: #f3e8c8 !important;
}
::placeholder {
    opacity: 0.5 !important;
}
a[href="https://coinmarketcap.com/"] > svg[width="94"][height="16"] > path {
    fill: var(--darkreader-neutral-text) !important;
}</style></head>

<body><h1>IJC: DU2</h1>

<hr>
<xmp>

Jazyk C                       DU2                      23.3.2021
----------------------------------------------------------------

                         Domácí úkol è.2


Termín odevzdání: 20.4.2021                       (Max. 15 bodù)

1) (max 5b)
   a) V jazyku C napi¹te program "tail.c", který  ze zadaného
   vstupního souboru vytiskne posledních  10 øádkù. Není-li
   zadán vstupní soubor, ète ze stdin. Je-li programu zadán
   parametr -n èíslo, bude se tisknout tolik posledních øádkù,
   kolik je zadáno parametrem 'èíslo' &gt; 0.
   Pøípadná chybová hlá¹ení tisknìte do stderr. Pøíklady:

     tail soubor
     tail -n +3 soubor
     tail -n 20 &lt;soubor

   [Poznámka: výsledky by mìly být +-stejné jako u POSIX pøíkazu tail]

   Je povolen implementaèní limit na délku øádku (napø. 511 znakù),
   v pøípadì prvního pøekroèení mezí hlaste chybu na stderr (øádnì otestujte)
   a pokraèujte se zkrácenými øádky (zbytek øádku pøeskoèit/ignorovat).


2) (max 10b)
   Pøepi¹te následující C++ program do jazyka ISO C

    // wordcount-.cc
    // Pou¾ijte: g++ -std=c++11 -O2
    // Pøíklad pou¾ití STL kontejneru unordered_map&lt;&gt;
    // Program poèítá èetnost slov ve vstupním textu,
    // slovo je cokoli oddìlené "bílým znakem"

    #include &lt;string&gt;
    #include &lt;iostream&gt;
    #include &lt;unordered_map&gt;

    int main() {
        using namespace std;
        unordered_map&lt;string,int&gt; m;  // asociativní pole
                     // mapuje klíè/string na hodnotu/int
        string word;
        while (cin &gt;&gt; word) // ètení slova (jako scanf "%s", ale bezpeèné)
            m[word]++;      // poèítání výskytù slova (zvý¹í hodnotu pro
                            // zadaný klíè/slovo pokud záznam existuje,
                            // jinak vytvoøí nový záznam s hodnotou 0 a
                            // tu operace ++ zvý¹í na 1)

        for (auto &amp;mi: m)   // pro v¹echny prvky kontejneru m
            cout &lt;&lt; mi.first &lt;&lt; "\t" &lt;&lt; mi.second &lt;&lt; "\n";
            //      klíè/slovo          hodnota/poèet
            // prvky kontejneru typu "map" jsou dvojice (klíè,hodnota)
    }

   Výstupy programù musí být pro stejný vstup stejné (kromì poøadí a pøíli¹
   dlouhých slov).

   Výsledný program se musí jmenovat "wordcount.c".

   Implementujte tabulku s rozptýlenými polo¾kami (hash table) - viz dále.
   Ve¹keré operace s tabulkou budou v samostatné knihovnì (vytvoøte statickou
   i dynamickou/sdílenou verzi).  V knihovnì musí být prakticky ka¾dá funkce ve
   zvlá¹tním modulu -- to napøíklad umo¾ní pøípadnou výmìnu htab_hash_function() ve va¹em
   staticky sestaveném programu. (V dynamicky sestaveném programu je to mo¾né v¾dy.)
   Vyzkou¹ejte si to: definujte svoji verzi htab_hash_function() v programu
   s podmínìným pøekladem -- pou¾ijte #ifdef HASHTEST.

   Knihovna s tabulkou se musí jmenovat
   "libhtab.a" (na Windows je mo¾né i "htab.lib") pro statickou variantu,
   "libhtab.so" (na Windows je mo¾né i "htab.dll") pro sdílenou variantu
   a rozhraní "htab.h".

   Podmínky:
    - Implementace musí být dynamická (malloc/free) a musíte zvládnout
      správu pamìti v C (pou¾ijte valgrind, nebo jiný podobný nástroj).

    - Vhodná rozptylovací funkce pro øetìzce je podle literatury
      (http://www.cse.yorku.ca/~oz/hash.html - varianta sdbm):

        size_t htab_hash_function(const char *str) {
          uint32_t h=0;     // musí mít 32 bitù
          const unsigned char *p;
          for(p=(const unsigned char*)str; *p!='\0'; p++)
              h = 65599*h + *p;
          return h;
        }

      její výsledek modulo arr_size urèuje index do tabulky:
        index = (htab_hash_function("mystring") % arr_size);
      Zkuste pou¾ít i jiné podobné funkce a porovnejte efektivitu.

    - Tabulka je (pro knihovnu privátní) struktura obsahující pole seznamù,
      jeho velikost a poèet polo¾ek tabulky v následujícím poøadí:

      +----------+
      | size     | // aktuální poèet záznamù [(key,data),next]
      +----------+
      | arr_size | // velikost následujícího pole ukazatelù
      +----------+
      +---+
      |ptr|--&gt;[(key,data),next]--&gt;[(key,data),next]--&gt;[(key,data),next]--|
      +---+
      |ptr|--|
      +---+
      |ptr|--&gt;[(key,data),next]--&gt;[(key,data),next]--|
      +---+
      |ptr|--|
      +---+

      Polo¾ka .arr_size je velikost následujícího pole ukazatelù (pou¾ijte
      C99: "flexible array member"). Pamì» pro strukturu se dynamicky alokuje
      tak velká, aby se do ní ve¹ly i v¹echny polo¾ky pole.
      V programu zvolte vhodnou velikost pole a v komentáøi zdùvodnìte va¹e
      rozhodnutí.
      (V obrázku platí velikost .arr_size==4 a poèet polo¾ek .size==5.)
      Rozhraní knihovny obsahuje jen _neúplnou_deklaraci_ struktury, definice
      je u¾ivateli knihovny skryta (jde o formu zapouzdøení - "encapsulation").

    - Napi¹te funkce podle následujícího hlavièkového souboru (API):

==================================================================
// htab.h -- rozhraní knihovny htab (øe¹ení IJC-DU2)
// Licence: ¾ádná (Public domain)

// následující øádky zabrání násobnému vlo¾ení:
#ifndef __HTAB_H__
#define __HTAB_H__

#include &lt;string.h&gt;     // size_t
#include &lt;stdbool.h&gt;    // bool

// Tabulka:
struct htab;    // neúplná deklarace struktury - u¾ivatel nevidí obsah
typedef struct htab htab_t;     // typedef podle zadání

// Typy:
typedef const char * htab_key_t;        // typ klíèe
typedef int htab_value_t;               // typ hodnoty

// Dvojice dat v tabulce:
typedef struct htab_pair {
    htab_key_t    key;          // klíè
    htab_value_t  value;        // asociovaná hodnota
} htab_pair_t;                  // typedef podle zadání

// Rozptylovací (hash) funkce (stejná pro v¹echny tabulky v programu)
// Pokud si v programu definujete stejnou funkci, pou¾ije se ta va¹e.
size_t htab_hash_function(htab_key_t str);

// Funkce pro práci s tabulkou:
htab_t *htab_init(size_t n);                    // konstruktor tabulky
htab_t *htab_move(size_t n, htab_t *from);      // pøesun dat do nové tabulky
size_t htab_size(const htab_t * t);             // poèet záznamù v tabulce
size_t htab_bucket_count(const htab_t * t);     // velikost pole

htab_pair_t * htab_find(htab_t * t, htab_key_t key);  // hledání
htab_pair_t * htab_lookup_add(htab_t * t, htab_key_t key);

bool htab_erase(htab_t * t, htab_key_t key);    // ru¹í zadaný záznam

// for_each: projde v¹echny záznamy a zavolá na nì funkci f
void htab_for_each(const htab_t * t, void (*f)(htab_pair_t *data));

void htab_clear(htab_t * t);    // ru¹í v¹echny záznamy
void htab_free(htab_t * t);     // destruktor tabulky

#endif // __HTAB_H__
==================================================================

      Hlavièkový soubor mù¾ete celý pøevzít (je v "Public domain").

    - Struèný popis základních funkcí:

        t=htab_init(numb)         konstruktor: vytvoøení a inicializace tabulky
                                  numb = poèet prvkù pole (.arr_size)

        t=htab_move(newnumb,t2)   move konstruktor: vytvoøení a inicializace
                                  nové tabulky pøesunem dat z tabulky t2,
                                  t2 nakonec zùstane prázdná a alokovaná
                                  (tuto funkci cviènì pou¾ijte v programu
                                   podmínìným pøekladem #ifdef MOVETEST)

        size_t s=htab_size(t)           vrátí poèet prvkù tabulky (.size)

        size_t n=htab_bucket_count(t)   vrátí poèet prvkù pole (.arr_size)

        ptr=htab_find(t,key)         vyhledávání - viz dále
        ptr=htab_lookup_add(t,key)   vyhledávání+pøidání - viz dále

        b=htab_erase(t,key)       zru¹ení záznamu se zadaným klíèem (úspìch:true)

        htab_for_each(t,funkce)   projde v¹echny záznamy, na ka¾dý zavolá funkci
                                  (pozor na mo¾né zmìny tabulky!)

        htab_clear(t)             zru¹ení v¹ech polo¾ek, tabulka zùstane prázdná

        htab_free(t)              destruktor: zru¹ení tabulky (volá htab_clear())

      kde t,t2    je ukazatel na tabulku (typu htab_t *),
          b       je typu bool,
          ptr     je ukazatel na záznam (polo¾ku tabulky {klíè,hodnota}),

    - Vhodnì zvolte typy parametrù funkcí (vèetnì pou¾ití const).

    - Záznam [(key,value),next] je typu
          struct htab_item
      a obsahuje polo¾ky:
          next ... ukazatel na dal¹í záznam
          struct htab_pair ... veøejná struktura s polo¾kami:
            key ..... ukazatel na dynamicky alokovaný øetìzec,
            value ... asociovaná data = poèet výskytù
      Tento záznam je definován v privátním hlavièkovém souboru pro v¹echny
      moduly tabulky a není dostupný pøi pou¾ití knihovny ("Opaque data type").
      U¾ivatel pou¾ívá ukazatel na vnoøenou strukturu htab_pair_t.

    - Funkce
        htab_pair_t *htab_find(htab_t *t, htab_key_t key);
      V tabulce  t  vyhledá záznam odpovídající øetìzci  key  a
        - pokud jej nalezne, vrátí ukazatel na záznam
        - pokud nenalezne, vrátí NULL

    - Funkce
        htab_pair_t htab_lookup_add(htab_t *t, htab_key_t key);
      V tabulce  t  vyhledá záznam odpovídající øetìzci  key  a
        - pokud jej nalezne, vrátí ukazatel na záznam
        - pokud nenalezne, automaticky pøidá záznam a vrátí ukazatel
      Poznámka: Dobøe promyslete chování této funkce k parametru key.
      Poznámka: podobnì se chová C++ operator[] pro std::unordered_map

    - Kdy¾ htab_init nebo htab_lookup_add nemohou alokovat pamì»,
      vrací NULL (a u¾ivatel musí testovat výsledek tìchto operací)


    Napi¹te funkci

        int read_word(char *s, int max, FILE *f);

      která ète jedno slovo ze souboru f do zadaného pole znakù
      a vrátí délku slova (z del¹ích slov naète prvních max-1 znakù,
      a zbytek pøeskoèí). Funkce vrací EOF, pokud je konec souboru.
      Umístìte ji do zvlá¹tního modulu "io.c" (nepatøí do knihovny).
      Poznámka: Slovo je souvislá posloupnost znakù oddìlená isspace znaky.

    Omezení: øe¹ení v C bude tisknout jinak uspoøádaný výstup
      a je povoleno pou¾ít implementaèní limit na maximální
      délku slova (napø. 127 znakù), del¹í slova se ZKRÁTÍ a program
      pøi prvním del¹ím slovu vytiskne varování na stderr (max 1 varování).

    Poznámka: Vhodný soubor pro testování je napøíklad seznam slov
              v souboru /usr/share/dict/words
              nebo texty z http://www.gutenberg.org/
              pøípadnì výsledek pøíkazu:  "seq 1000000 2000000|shuf"

(10b)

Pou¾ijte implicitní lokalizaci (= nevolat setlocale()). Zamyslete se nad tím,
jaké problémy by pøineslo pou¾ití UTF-8 pøi zapnuté lokalizaci s tímto
dnes bì¾nì pou¾ívaným kódováním.

Napi¹te soubor Makefile tak, aby pøíkaz make vytvoøil programy
"tail", "wordcount", "wordcount-dynamic" a knihovny "libhtab.a",
"libhtab.so" (nebo "htab.dll" atd.).

Program "wordcount" musí být staticky sestaven s knihovnou "libhtab.a".

Program "wordcount-dynamic" musí být sestaven s knihovnou "libhtab.so".
Tento program otestujte se stejnými vstupy jako u staticky sestavené verze.

Porovnejte efektivitu obou (C i C++) implementací (viz napø. pøíkaz time)
a zamyslete se nad výsledky (pozor na vliv vyrovnávacích pamì»í atd.)
Také si zkuste pøeklad s optimalizací i bez ní (-O2, -O0) a porovnejte
efektivitu pro vhodný vstup.

Poznámky:
 - pro testy wordcount-dynamic na linuxu budete potøebovat nastavit
      LD_LIBRARY_PATH="."   (viz "man ld.so" a odpovídající pøedná¹ka)
 - Ètìte pokyny pro vypracování domácích úkolù (viz dále)

----------------------------------------------------------------

Obecné pokyny pro vypracování domácích úkolù

*  Pro úkoly v jazyce C pou¾ívejte ISO C99 (soubory *.c)
   Pro úkoly v jazyce C++ pou¾ívejte ISO C++17 (soubory *.cc)
   Pou¾ití nepøenositelných konstrukcí v programech není dovoleno.

*  Úkoly zkontrolujte pøekladaèem napøíklad takto:
      gcc -std=c99 -pedantic -Wall -Wextra priklad1.c
      g++ -std=c++17 -pedantic -Wall priklad.cc
   Místo gcc mù¾ete pou¾ít i jiný pøekladaè - podle va¹eho prostøedí.
   V  souvislosti s tím napi¹te do poznámky na zaèátku
   souboru jméno a verzi pøekladaèe, kterým byl program pøelo¾en
   (implicitní je GCC `g++ --version` na poèítaèi merlin).

*  Programy  pi¹te, pokud je to mo¾né, do jednoho zdrojového
   souboru. Dodr¾ujte pøedepsaná jména souborù.

*  Na zaèátek ka¾dého souboru napi¹te poznámku, která bude
   obsahovat jméno, fakultu, oznaèení pøíkladu a datum.

* Úkoly je nutné zabalit programem zip takto:
       zip xnovak99.zip *.c *.cc *.h Makefile

  Jméno xnovak99 nahradíte vlastním. Formát souboru bude ZIP.
  Archiv neobsahuje adresáøe.  Ka¾dý si zkontroluje obsah ZIP archivu jeho
  rozbalením v prázdném adresáøi a napsáním "make".

* Posílejte pouze nezbytnì nutné soubory -- ne *.EXE !

* Øe¹ení se odevzdává elektronicky v IS FIT

* Úkoly neodevzdané v termínu (podle WIS) budou za 0 bodù.

* Opsané úkoly budou hodnoceny 0 bodù pro v¹echny zùèastnìné
  a to bez výjimky (+ bonus v podobì náv¹tìvy u disciplinární komise).


</xmp>
<hr>
<address>
Poslední modifikace: <!-- begin flastmod -->
23. March 2021<!-- end -->
<br>
Pokud naleznete na této stránce chybu, oznamte to dopisem na adresu
peringer AT fit.vutbr.cz
</address>



</body></html>